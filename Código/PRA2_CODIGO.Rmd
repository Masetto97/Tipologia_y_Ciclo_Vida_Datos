---
title: '¿Cómo realizar la limpieza y análisis de datos?'
author: "Autores: Eduardo Mora González y Diego Sánchez De La Fuente"
date: "Enero 2023"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: 75.584-PEC-header.html
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Instalamos y cargamos las librerías necesarias.

```{r message= FALSE, warning=FALSE}
if (!require('readr')) install.packages('readr'); library('readr')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('DataExplorer')) install.packages('DataExplorer'); library('DataExplorer')
if (!require('corrplot')) install.packages("corrplot"); library(corrplot)
if (!require('factoextra')) install.packages("factoextra"); library(factoextra)
if (!require('dplyr')) install.packages("dplyr"); library(dplyr)
```


# CARGA DEL FICHERO DE DATOS

```{r message= FALSE, warning=FALSE}
datos <- read_csv("./fichero_original_datos.csv")
attach(datos)
```


# Descripción del dataset:

El conjunto de datos ha sido extraido de Kaggle: https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset, está compuesto de 12 variables y 918 registros. Que correlacionan una serie de caracteristicas recogidas de varios pacientes con la posibilidad de sufrir un ataque al corazón.

Explicación de cada variable:

- **Age**: Edad del paciente
- **Sex**: Sexo del paciente
- **ChestPainType**: Tipo de dolor torácico:
        Angina Típica
        Angina Atípica
        Dolor no debido a una angina
        Asintomático
- **RestingBP**: Presión arterial en reposo (en mm Hg)
- **Cholesterol**: Colesterol en sangre (mg/dL)
- **FastingBS**: Tiene Glucemia en ayunas > 120 mg/dl -> (1: True, 0: False) 
- **RestingECG**: Resultados electrocardiográficos en reposo
        Value 0: normal
        Value 1: Tiene anormalidad de la onda ST-T (inversiones de la onda T y/o elevación o depresión del ST > 0.05 mV)
        Value 2  Muestra hipertrofia ventricular izquierda probable o definitiva según los criterios de Estes
- **MaxHR**: Frecuencia cardíaca máxima alcanzada
- **ExerciseAngina**: Angina inducida por el ejercicio (1 = sí, 0 = no)
- **Oldpeak**: Descenso del segmento ST inducido por el ejercicio en relación con el reposo ('Segmento ST' se relaciona con las posiciones en el gráfico de Electro cardiograma). 
- **ST_Slope**: La pendiente del segmento ST de ejercicio máximo: 
	0: pendiente descendente 
	1: plano 
	2: pendiente ascendente
- **HeartDisease**: Variable Objetivo: 0= menos posibilidades de infarto 1= más posibilidades de infarto.

Tipo de dato asignado a cada campo:

```{r}
# Cargamos en un vector los tipos de variable del datase
vector_tipos <- sapply(datos, function(x) class(x))
print(vector_tipos)
```


Ahora vamos a ver las estructura del juego de datos

```{r message= FALSE, warning=FALSE}
str(datos)
```

Vamos ahora a sacar estadísticas básicas
  
```{r message= FALSE, warning=FALSE}
summary(datos)
```

Observamos los primeros 5 registros:


```{r}
head(datos, 5L)
```

# Preprocesado y gestión de características

## Valores nulos del conjunto de los datos

De tipo numérico

```{r message= FALSE, warning=FALSE}
colSums(is.na(datos))
```

De tipo cadena

```{r message= FALSE, warning=FALSE}
colSums(datos=="")
```

Como se puede comprobar, tenemos la “suerte” de no tener ningún valor nulo o vacío en los dos juegos de datos.



## Normalización del conjunto de los datos

### EDAD

```{r message= FALSE, warning=FALSE}
#Histograma de la característica edad del primer conjunto de datos 
h1 <- hist(datos$Age, xlab="Edad", col="ivory",
           ylab="Cantidad", main="EDAD ", ylim = c(0, 225), xlim = c(20,80))
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
```

Como se puede observar, la franja de entre los 50 y 60 años son donde más datos existen, mientras que los extremos donde menos datos.


### SEXO
  
Normalizamos para tenerlo de tipo numérico todas la variables
  
```{r message= FALSE, warning=FALSE}
#Cambiamos las letras por los números
datos$Sex [datos$Sex == "M"] <- 1
datos$Sex [datos$Sex == "F"] <- 0

#Pasamos de carácter a numérico
datos$Sex <- as.numeric(datos$Sex)
```


Una vez normalizada la característica , analizamos el conjunto de los datos contemplados en esta.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$Sex, xlab="Sexo", col=c("ivory", "lightcyan"),
           ylab="Cantidad", main="SEXO", breaks = 2, ylim = c(0, 750), axes = FALSE)
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25, 0.75), cex.axis=1, labels = c("Mujeres","Hombres" ))
axis(2)
```

### TIPO DE DOLOR TORÁCICO (ChestPainType)

Nos damos cuenta de que el conjunto de datos viene identificado por 4 variables categóricas (TA: angina típica, ATA: angina atípica, NAP: dolor no anginal, ASY: asintomático). Normalizamos para tenerlo de tipo numérico todas la variables:

```{r message= FALSE, warning=FALSE}
#Cambiamos las letras por los números
datos$ChestPainType [datos$ChestPainType == "TA"]  <- 0
datos$ChestPainType [datos$ChestPainType == "ATA"] <- 1
datos$ChestPainType [datos$ChestPainType == "NAP"] <- 2
datos$ChestPainType [datos$ChestPainType == "ASY"] <- 3

#Pasamos de carácter a numérico
datos$ChestPainType <- as.numeric(datos$ChestPainType)
``` 

Una vez normalizada la característica , analizamos el conjunto de los datos contemplados en esta.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$ChestPainType, xlab="Tipo de dolor torácico",
           col= c("ivory", "lightcyan", "ORANGE", "PINK"), 
           ylab="Cantidad", main="TIPO DOLOR TORÁCICO", 
           ylim = c(0, 550),axes = FALSE, 
           breaks=seq(min(datos$ChestPainType)-0.5,
                      max(datos$ChestPainType)+0.5, by=1) )
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0,1,2,3), cex.axis=1,
     labels = c("Angina típica", "Angina atípica","Dolor no anginal", "Asintomático" ))
axis(2)
```

como se puede comprobar, tenemos mas casos de de asintomaticos que del resto.

### PRESIÓN ARTERIAL EN REPOSO (RestingBP)
  
Como se muestran en las estadísticas esta característica es de tipo numérico y en el conjunto de datos va desde 0 hasta 200. Como se puede apreciar, tener una presión arterial de 0 es estar considerado muerto, por lo que considero que el valor 0 es un valor nulo.

Lo primero que se va a hacer es obtener el número de casos que la presión arterial es 0, y se consideraran las diversas formas de tratar estos datos:

```{r message= FALSE, warning=FALSE}
#Veces que aparece el valor cero en la presion arterial
length(datos$RestingBP[datos$RestingBP == 0])
```

Como solo aparece una vez, se le asignará un valor por defecto. El valor por defecto será el más común.

```{r message= FALSE, warning=FALSE}
#Función para calcular el valor más común
common_value <- function(x) {
uniqx <- unique(na.omit(x))
uniqx[which.max(tabulate(match(x, uniqx)))]
}

#Calculamos el valor más comun
BP_comun <- common_value(datos$RestingBP)

#Asignamos el valor
datos$RestingBP[datos$RestingBP == 0] <- BP_comun

#vemos las estaditicas del dato
summary(datos$RestingBP)
```

Ahora ya tenemos los valores entre 80 y 200 que son un rango normal para estos valores.

```{r message= FALSE, warning=FALSE}
#Histograma de la característica Presión Arterial del primer conjunto de datos 
h1 <- hist(datos$RestingBP, xlab="Presión Arterial", col="ivory", 
           ylab="Cantidad", main="PRESIÓN ARTERIAL EN REPOSO",
           ylim = c(0, 225), xlim = c(80,200))
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
```

### COLESTEROL (Cholesterol)
  
La siguiente característica es de tipo numérico. Al igual que en la presión arterial en reposo, que tenemos valores 0 que debemos analizar. Lo primero que se va a hacer es obtener el numero de casos que el colesterol es 0, y se consideraran las diversas formas de tratar estos datos.

```{r message= FALSE, warning=FALSE}
#Veces que aparece el valor cero en la presion arterial
length(datos$RestingBP[datos$Cholesterol == 0])
```

Esta vez tenemos 172 casos en lo que ocurre esto (equivale a un 18% de los casos totales). Antes de ver que valor se le asignan, se va a graficar los datos para ver de manera grafica que opción tomar: el valor medio o el más común.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$Cholesterol, xlab="Colesterol", col="ivory",
           ylab="Cantidad", main="COLESTEROL SIN TRATAR NULOS", ylim = c(0,300),
           xlim = c(0, 700))
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
```

Tras analizar la gráfica y para no perder estos datos, se le asignaran un valor por defecto, que será la media de los datos. Esta decisión se ha tomado ya que poner el más común, nos crearía un conjunto de datos muy distintos entre unas medidas y otras, mientras que poner la media sería un valor que tenga en cuenta el grueso de todos los datos.


```{r message= FALSE, warning=FALSE}
#Calculamos el valor más comun
colesterol_media <- mean(datos$Cholesterol)

#Asignamos el valor truncado para evitar decimales
datos$Cholesterol[datos$Cholesterol == 0] <- trunc(colesterol_media)

#vemos las estaditicas del dato
summary(datos$RestingBP)
```

Ahora ya tenemos los valores entre 80 y 200 que son un rango normal para estos valores.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$Cholesterol, xlab="Colesterol", col="ivory",
           ylab="Cantidad", main="COLESTEROL", ylim = c(0,330), xlim = c(0, 700))
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
```

### NIVEL DE AZÚCAR EN SANGRE EN AYUNAS (FastingBS)
  
Como se puede comprobar el conjunto de los datos puedes ser 1 o 0, es decir verdadero o falso si se cumple la siguiente condición: si nivel de azúcar en sangre en ayunas> 120 mg / dl.

En esta característica no tenemos valores nulos, así que vamos a ver la distribución de las dos opciones:

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$FastingBS, xlab="¿Azúcar en sangre en ayunas> 120 mg / dl?",
           col=c("ivory", "lightcyan"), ylab="Cantidad",
           main="NIVEL DE AZÚCAR", breaks = 2, ylim = c(0, 750), axes = FALSE)
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25, 0.75), cex.axis=1, labels = c("NO","SI" ))
axis(2)
```

Como se puede comprobar que hay mas casos que NO se cumple esa condición de que SÍ.

### ECG EN REPOSO (RestingECG)

Nos damos cuenta de que el conjunto de datos viene identificado por 3 variables categóricas:
 + Normal: Normal, 
 + ST: con anomalía de la onda ST-T
 + LVH: que muestra una hipertrofia ventricular izquierda probable o definitiva según los criterios de Estes.
Normalizamos para tenerlo de tipo numérico todas la variables:

```{r message= FALSE, warning=FALSE}
#Cambiamos las letras por los números
datos$RestingECG [datos$RestingECG == "Normal"]  <- 0
datos$RestingECG [datos$RestingECG == "ST"] <- 1
datos$RestingECG [datos$RestingECG == "LVH"] <- 2

#Pasamos de carácter a numérico
datos$RestingECG <- as.numeric(datos$RestingECG)
```

Una vez normalizada la característica , analizamos el conjunto de los datos contemplados en esta.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$RestingECG, xlab="ECG en reposo",
           col= c("ivory", "lightcyan", "ORANGE"),
           ylab="Cantidad", main="ECG EN REPOSO",
           ylim = c(0, 600), axes = FALSE,
           breaks=seq(min(datos$RestingECG)-0.5,
                      max(datos$RestingECG)+0.5, by=1) )
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25, 1, 1.75 ), cex.axis=1, labels = c("Normal","ST", "LVH"))
axis(2)
```

### FRECUENCIA CARDÍACA MÁXIMA (MaxHR)

Dicha característica es de carácter numérica y en el conjunto de datos contempla valores desde el 60 al 202 

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$MaxHR, xlab="Frecuencia Cardíaca Máxima",
           col="ivory", ylab="Cantidad", main="FRECUENCIA CARDÍACA MÁXIMA",
           ylim = c(0,140), axes = FALSE)
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(60, 70, 80,90,100,110,120,130,140,150,160,170,180,190,200,210), cex.axis=1)
axis(2)
```

Se puede comprobar que los extremos en el conjunto de datos tienen menos valores, y que el grueso de las muestras se encuentran entre los valores centrales (desde 100 a 180).

### ANGINA INDUCIDA POR EJERCICIO (ExerciseAngina)
  
En el  conjunto de datos tiene los valores Y: Sí, N: No. Al igual que se ha hecho con otras características, se normalizará el conjunto.

```{r message= FALSE, warning=FALSE}
#Cambiamos las letras por los números
datos$ExerciseAngina [datos$ExerciseAngina == "N"]  <- 0
datos$ExerciseAngina [datos$ExerciseAngina == "Y"]  <- 1

#Pasamos de carácter a numérico
datos$ExerciseAngina <- as.numeric(datos$ExerciseAngina)
```

Una vez normalizada la característica , analizamos el conjunto de los datos contemplados en esta.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$ExerciseAngina, xlab="¿Angina inducida por ejercicio?",
           col=c("ivory", "lightcyan"), ylab="Cantidad", main="ANGINA INDUCIDA",
           breaks = 2, ylim = c(0, 600), axes = FALSE)
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25, 0.75), cex.axis=1, labels = c("NO","SI" ))
axis(2)
```

Como se puede apreciar, hay mas casos en que NO se ha producido una angina inducida por el ejercicio de que Si se haya producido.

### OLDPEAK
  
Esta característica de tipo numérica puede abarcar valores negativos hasta  hasta un máximo de un valor igual a 6,2.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$Oldpeak, xlab="Oldpeak", col="ivory", ylab="Cantidad", main="OLDPEAK", ylim = c(0,400), xlim = c(-4, 8))
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
```

Se puede comprobar que el grueso de las muestras se encuentra entre los valores centrales teniendo una distribución normal

### PENDIENTE DEL SEGMENTO ST (ST_Slope)

Como ocurría en otras características anteriores el conjunto tiene los valores para esta caracteristica de la siguiente forma:
  + Up: uploping
  + Flat: flat
  + Down: downsloping
Y como se ha realizado antes, se normalizará para solo tener datos numericos.

```{r message= FALSE, warning=FALSE}
#Cambiamos las letras por los números
datos$ST_Slope [datos$ST_Slope == "Up"]   <- 0
datos$ST_Slope [datos$ST_Slope == "Flat"] <- 1
datos$ST_Slope [datos$ST_Slope == "Down"] <- 2

#Pasamos de carácter a numérico
datos$ST_Slope <- as.numeric(datos$ST_Slope)
```

Una vez normalizada la característica , analizamos el conjunto de los datos contemplados en esta.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$ST_Slope, xlab="Pendiente del segmento ST",
           col= c("ivory", "lightcyan", "ORANGE"), ylab="Cantidad",
           main="PENDIENTE DEL SEGMENTO ST", ylim = c(0, 500),
           axes = FALSE,breaks=seq(min(datos$ST_Slope)-0.5, max(datos$ST_Slope)+0.5, by=1) )
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25,1,1.75), cex.axis=1, labels = c("Ascendente","Plano", "Descendente"))
axis(2)
```

El caso más común es que la pendiente sea plana, teniendo menos casos en los casos descendentes.

### ¿ENFERMEDAD CARDIACA? (HeartDisease)

En el conjunto de datos tienen normalizada la salida usando el valor 1: enfermedad cardíaca, y el valor 0: Normal.

```{r message= FALSE, warning=FALSE}
h1 <- hist(datos$HeartDisease, xlab="¿Enfermedad Cardiaca?",
           col=c("ivory", "lightcyan"),
           ylab="Cantidad", main="¿ENFERMEDAD CARDIACA?",
           breaks = 2, ylim = c(0, 600), axes = FALSE)
text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
axis(1, at =c(0.25, 0.75), cex.axis=1, labels = c("NO","SI" ))
axis(2)
```

Como se puede observar hay mas casos en que SI hay enfermedad cardiaca que caso en los que NO hay.

## Construcción de conjunto de datos final

Renombramos las columnas para que tenga uno mas significativo y creamos el conjunto final de datos.


```{r message= FALSE, warning=FALSE}

datos_final <- datos

colnames(datos_final)[1]<-  "EDAD"
colnames(datos_final)[2]<-  "SEXO"
colnames(datos_final)[3]<-  "TIPO DOLOR TORAX"
colnames(datos_final)[4]<-  "PRESIÓN ARTERIAL"
colnames(datos_final)[5]<-  "COLESTEROL"
colnames(datos_final)[6]<-  "NIVEL DE AZÚCAR"
colnames(datos_final)[7]<-  "ECG EN REPOSO"
colnames(datos_final)[8]<-  "FREC CARDÍACA MÁX"
colnames(datos_final)[9]<-  "ANGINA x EJERCICIO"
colnames(datos_final)[10]<- "OLDPEAK"
colnames(datos_final)[11]<- "PENDIENTE ST"
colnames(datos_final)[12]<- "E. CARDIACA"

```


Por ultimo se va a mirar a través de los diagramas de cajas el rango de las características enfrentado a si un paciente tiene una enfermedad cardiaca o no.

```{r message= FALSE, warning=FALSE}
#Diagrama de caja de todas las características enfrentadas a si un paciente tiene enfermedad cardiaca
plot_boxplot(datos_final, by = "E. CARDIACA")
```
## Eliminamos outliers



```{r}
datos_bp.colesterol <- boxplot(datos_final$COLESTEROL)
datos_bp.colesterol.out <- datos_bp.colesterol$out
print("Eliminamos Outliers de la variable COLESTEROL con valores: ")
datos_bp.colesterol.out
datos_final <- datos_final %>% filter(!(COLESTEROL %in% datos_bp.colesterol.out))

datos_frec.cardiaca.max <- boxplot(datos_final$`FREC CARDÍACA MÁX`)
datos_frec.cardiaca.max.out <- datos_frec.cardiaca.max$out
print("Eliminamos Outliers de la variable FREC CARDIACA MAX con valores: ")
datos_frec.cardiaca.max.out
datos_final <- datos_final %>% filter(!(`FREC CARDÍACA MÁX` %in% datos_frec.cardiaca.max.out))

datos_oldpeak <- boxplot(datos_final$OLDPEAK)
datos_oldpeak.out <- datos_oldpeak$out
print("Eliminamos Outliers de la variable OLDPEAK con valores: ")
datos_oldpeak.out
datos_final <- datos_final %>% filter(!(OLDPEAK %in% datos_oldpeak.out))

datos_bp.presion_arterial <- boxplot(datos_final$`PRESIÓN ARTERIAL`)
datos_bp.presion_arterial.out <- datos_bp.presion_arterial$out
print("Eliminamos Outliers de la variable PRESIÓN ARTERIAL ST con valores: ")
datos_bp.presion_arterial.out
datos_final <- datos_final %>% filter(!(`PRESIÓN ARTERIAL` %in% datos_bp.presion_arterial.out))

datos_bp.tipo_dolor_torax <- boxplot(datos_final$`TIPO DOLOR TORAX`)
datos_bp.tipo_dolor_torax.out <- datos_bp.tipo_dolor_torax$out
print("Eliminamos Outliers de la variable TIPO DOLOR TORAX con valores: ")
datos_bp.tipo_dolor_torax.out
datos_final <- datos_final %>% filter(!(`PRESIÓN ARTERIAL` %in% datos_bp.tipo_dolor_torax.out))
```




## Correlaciones

```{r message= FALSE, warning=FALSE}
#Calculamos las correlaciones
cor_datos <- cor(datos_final)
cor_datos
```


```{r message= FALSE, warning=FALSE}
#Representación de las correlaciones
corrplot(cor_datos, method = "pie", type="upper")
```

## Análisis de componentes principales (PCA)

Ahora se va a realizar un análisis de componentes sobre el conjunto de datos final. Lo primero que vamos a calcular es la varianza de todas las caracteristicas

```{r message= FALSE, warning=FALSE}
#Cálculo de la varianza de los componentes.
var <- apply(datos_final, 2, var)
var
```

Como se puede observar de una manera bastante clara, el colesterol es la característica que mas varia de un individuo a otro.

Lo siguiente es centrar y escalar las características, para que así las variables pierdan esa variabilidad. Una vez calculada la matriz se la asigno al pca

```{r message= FALSE, warning=FALSE}
#Calculo de la descomposición de los componentes
pca <- prcomp(datos_final, scale = TRUE, center = TRUE)
pca
```

Se puede ver que la primera componente tiene la mayor desviación estándar de todos los componentes. Para verlo de una manera mas clara, se va a representar de una manera grafica la salida anterior

```{r message= FALSE, warning=FALSE}
#Representación PCA´s anteriores
fviz_eig(pca)
```

Como se ha visto antes, tanto de una manera numérica como gráfica, el PC1 es el que mejor de todos con una diferencia notable. Si usamos la técnica del codo, deberíamos coger solamente las dos primeras componentes.

Para confirmar la interpretación, no estaría de más obtener las estadísticas de todas las componentes

```{r message= FALSE, warning=FALSE}
#Estadísticas de las componentes
summary(pca)
```

Viendo las estadísticas vemos que con las dos primeras componentes solamente podríamos explicar un 39,75% de los datos.Como no queremos perder información en el modelo, nos tendríamos que quedar con todas las componentes. Para verlo de una manera visual, se va a representar la PCA de una manera gráfica.

```{r message= FALSE, warning=FALSE}
#Representación de variables sobre componentes principales
fviz_pca_var(pca, repel = TRUE, scale = 0)
```

```{r message= FALSE, warning=FALSE}
#Representación de observaciones sobre componentes principales
fviz_pca_ind(pca, col.ind = "cos2", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
```

```{r message= FALSE, warning=FALSE}
#Representa la contribución de filas/columnas de los resultados de un pca
fviz_contrib(pca,choice = "var") 
```

Una vez que hemos representada las variables y los individuos, se va a fusionar estas dos gráficas

```{r message= FALSE, warning=FALSE}
#Representación de variables y los individuos en la misma gráfica
fviz_pca_biplot(pca, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")
```

Aunque la opción de repelerse esta activada al ser bastantes casos no se puede ver una manera correcta, así que se a mostrar solamente los 10, 50 y 100 casos más influyentes

```{r message= FALSE, warning=FALSE}
#Representación de variables y los 10 individuos más influyentes en la misma gráfica
fviz_pca_biplot(pca, repel = TRUE, col.var = "#2E9FDF",
                col.ind = "#696969", select.ind = list(contrib = 10))

#Representación de variables y los 50 individuos más influyentes en la misma gráfica
fviz_pca_biplot(pca, repel = TRUE, col.var = "#2E9FDF",
                col.ind = "#696969", select.ind = list(contrib = 50))

#Representación de variables y los 100 individuos más influyentes en la misma gráfica
fviz_pca_biplot(pca, repel = TRUE, col.var = "#2E9FDF",
                col.ind = "#696969", select.ind = list(contrib = 100))
```

Al mostrar solamente los casos mas influyentes, se puede ver con mas claridad las relaciones entre los individuos y las características. Podemos concluir de este análisis de componentes, que no se puede quitar ninguna característica ya que se perdería información.


# Exportación de los datos

Una vez que hemos acometido sobre el conjunto de datos inicial los procedimientos de integración, validación y limpieza anteriores, procedemos a guardar estos en un nuevo fichero denominado heart_dissease_data_clean.csv:


```{r message= FALSE, warning=FALSE}
# Exportación de los datos limpios en .csv
write.csv(datos_final, "./heart_dissease_data_clean.csv")
```



# Análisis de los datos

## COmprobación de la normalidad y la homogeneidad de la varianza


Para la comprobación de que los valores que toman nuestra variables cuantativa provienen de una distirbución normal vamos a utilizar la prueba de normalidad de Anderson-Darling.

Podemos comprobar que para cada prueba se obtiene un p-valor superior al nivel de significancia estadistica prefijado en alpha = 0,05. Si esto se cumple, entonces se considera que variable en cuestion sigue la distribución normal.


```{r message= FALSE, warning=FALSE}
if (!require('nortest')) install.packages('nortest'); library('nortest')
alpha = 0.05
col.names = colnames(datos_final)
ind = 1

# Comprobanos unicamente lS variables que inicialmente eran de tipo numericas

for (i in colnames(datos_final)) {
  if (ind == 1) cat("Variables que no siguen una distribución normal:\n")
  if(vector_tipos[ind] == "numeric")
  {
    p_val = ad.test(unlist(datos_final[i]))$p.value
    if (p_val < alpha) {
      cat(i)
      # Format output
        if (ind < ncol(datos) - 1) cat(", ")
        if (ind %% 3 == 0) cat("\n")
      }
  }
  ind = ind + 1
  }
```
Podemos realizar un Q-Q plot para comprobar si las variables obtenidas en el anterior punto no siguen una distribución normal.


```{r}
# Edad
variables <- c("EDAD", "PRESIÓN ARTERIAL", "COLESTEROL",
               "NIVEL DE AZÚCAR", "FREC CARDÍACA MÁX", "OLDPEAK")


for(i in(variables))
{
  qqnorm(unlist(datos_final[i]),  main = paste0("Q-Q para la variable: ", i));qqline(unlist(datos_final[i]), col = 2)
}

```


# Pruebas estadisticas

## ¿Que variables cuantitativas ejercen mayor influencia en la variable que define si hay una enfermedad cardica

```{r message= FALSE, warning=FALSE}
corr_matrix <- matrix(nc=2, nr=0)
colnames(corr_matrix) <- c("estimate", "p-value")

# Calculamos el coficiente de correlacion para cada variable cuantitativa
# con respecto al campo E. CARDICA

for(i in 1:(ncol(datos_final) -1 ))
{
  if(vector_tipos[i] == "numeric")
  {
    spearman_test = cor.test(unlist(datos_final[,i]),
                              unlist(datos_final[,length(datos_final)]),
                              method = "spearman")
    corr_coef <- spearman_test$estimate
    p_val <- spearman_test$p.value
    
    # Aañade a la matriz
    pair <- matrix(ncol = 2, nrow = 1)
    pair[1][1] = corr_coef
    pair[2][1] = p_val
    corr_matrix <- rbind(corr_matrix, pair)
    rownames(corr_matrix)[nrow(corr_matrix)] <- colnames(datos_final)[i]
  }
  
}

print(corr_matrix)

```
Podemos identificar cual es la variable más correlacionada con la variable Enfermedad Cardiaca, viendo cuales de los valores de la columan estimate se acercan más al valor +1 o -1, en este caso los más cercanos y por lo tanto los que más correlacionados están con la varibale objetivo son: OLDPEAK y FREC CARDÍACA MAX.

Por otro lado en la columna p-value, tenemos el indicador del peso estadistico de dicga variable, en este caso las variables que tienen peso estadistico más alto son: COLESTEROL y PRESION ARTERIAL.

# Grupos de datos

Podemos establecer una serie de grupos partiendo de nuestro dataset para analizar y/o comparlos más adelante


```{r}
# Agrupación por Tipo de dolor de torax
# [0: TA; 1: ATA ; 2: NAP ; 3: ASY]
datos_final.angina_tipica <- datos_final[datos_final$`TIPO DOLOR TORAX` == 0,] 
datos_final.angina_atipica <- datos_final[datos_final$`TIPO DOLOR TORAX` == 1,] 
datos_final.no_angina <- datos_final[datos_final$`TIPO DOLOR TORAX` == 2,] 
datos_final.asintomatico <- datos_final[datos_final$`TIPO DOLOR TORAX` == 3,]

# Agrupación por pacientes con Hiperglucemia
datos_final.sin_hiperglucemia <- datos_final[datos_final$`NIVEL DE AZÚCAR` == 0,] 
datos_final.con_hiperglucemia <- datos_final[datos_final$`NIVEL DE AZÚCAR` == 1,]

# Agrupación por pacientes con Angina inducida
datos_final.sin_angina_inducida <- datos_final[datos_final$`ANGINA x EJERCICIO` == 0,] 
datos_final.con_angina_inducida <- datos_final[datos_final$`ANGINA x EJERCICIO` == 1,]

# Agrupación por ECG en reposo
# ["Normal": 0, "ST": 1, "LVH": 2]

datos_final.ecg_normal <- datos_final[datos_final$`ECG EN REPOSO` == 0,] 
datos_final.ecg_st <- datos_final[datos_final$`ECG EN REPOSO` == 1,] 
datos_final.ecg_lvh <- datos_final[datos_final$`ECG EN REPOSO` == 2,] 

```



```{r message= FALSE, warning=FALSE}

```


```{r message= FALSE, warning=FALSE}

```


```{r message= FALSE, warning=FALSE}

```

